.TH "icmake" "1" "1992\-2017" "icmake\&.9\&.02\&.03\&.tar\&.gz" "A program maintenance utility"

.PP 
.SH "NAME"
icmake \- A program maintenance (\fImake\fP) utility using a
\fBC\fP\-like grammar
.PP 
.SH "SYNOPSIS"
\fBicmake\fP [options] \fIsource[\&.im] [dest[\&.bim]]\fP [\-\- [args]]
.PP 
\fBicmun\fP \fIbimfile\fP
.PP 
.SH "DESCRIPTION"

.PP 
\fBIcmake\fP(1) was designed as a generic tool that can be used as an
alternative to \fBmake\fP(1), handling program maintenance\&. It\(cq\&s a generic tool
in that \fIicmake\fP\-scripts, written in a language closely resembling
the \fBC\fP programming language, can perform tasks that are traditionally the
domain of scripting languages\&. 
.PP 
\fBIcmake\fP allows programmers to use a programming language (closely resembling the
well\-known \fBC\fP\-programming language) to define the actions that are required
for (complex) program maintenance\&. For this, \fBicmake\fP offers various special
operators as well as a set of support functions that have shown their
usefulness in program maintenance\&.
.PP 
Although \fIicmake\fP\-scripts can be written from scratch for handling program
maintenance, often the required activities are highly comparable\&. This
observation resulted in the construction of two \fIicmake\fP\-scripts:
\fBicmstart\fP(1), initializing a directory for program development and
\fBicmbuild\fP(1), handling the actual program maintenance\&. Both come predefined
as scripts tailored to initializing and maintaining \fBC++\fP programs (or,
after minimal adaptation, \fBC\fP programs), but can easily be adapted to
other programming languages\&. Both \fIicmstart\fP and \fIicmbuild\fP can be run
without explicitly calling \fIicmake\fP\&.
.PP 
This man\-page covers \fIicmake\fP (the program), its support programs and
the syntax and facilities offered by \fIicmake\(cq\&s\fP scripting language\&. Refer to
the \fBicmstart\fP(1)) man\-page for information about how a directory can be
initialized (created) in which (by default) a \fBC++\fP or \fBC\fP program can be
developed and refer to the \fBicmbuild\fP(1) man\-page for information about how
\fIicmbuild\fP can be used to handle program maintenance\&.
.PP 
It should be stressed that \fIicmake\fP and its support programs and scripts do
not offer an \fIIntegrated Development Environment\fP (IDE)\&. It merely performs
tasks for which scripts can be written, and it offers just a few pre\-defined
scripts (\fIicmstart\fP and \fIicmbuild\fP) that repeatedly have shown to be
extremely useful when developing and maintaining programs\&. 
.PP 
In its standard operation mode, \fIicmake\fP calls the following programs:
.IP o 
\fIicm\-pp\fP  to preprocess the icmake file 
.IP o 
\fIicm\-comp\fP   to byte\-code compile the \fBicmake\fP  \fBs\fP
.IP o 
\fIicm\-dep\fP to handle class\-dependencies (see section \fBICM\-DEP\fP
in \fBicmbuild\fP(1)\(cq\&s man\-page for more information about
\fIicm\-dep\fP)\&.
.IP o 
\fIicm\-exec\fP   to execute the byte\-code file

.PP 
The program \fBicmun\fP(1) can be used to disassemble the compiled byte\-code
(\&.bim) file\&. \fIIcmun\fP is mainly used for illustration, education, and
debugging\&. As it is not required for \fIicmake\fP\(cq\&s daily use it is not
installed in a standard \fIPATH\fP directory but (since \fIicmake\(cq\&s\fP version
9\&.02\&.00) in \fIicmake\(cq\&s\fP \fIlib\fP directory, commonly \fI/usr/lib/icmake\fP\&.
.PP 
Traditional make\-utilities recompile sources once header files are
modified\&. When developing \fBC++\fP programs this is often a bad idea, as adding
a new member to a class does not normally require you to recompile all of the
class\(cq\&s source files\&. To handle class dependencies \fBicmbuld\fP(1) may inspect
class dependencies, (re)compiling sources of dependent classes whenever
necessary\&.  By default, class\-dependencies are not interpreted, but this can
easily be changed by activating the \fIPRECOMP\fP and/or \fIUSE_ALL\fP defines in
\fIicmconf\fP\&. Refer to the \fBicmconf\fP(7) man\-page for further details\&. 
.PP 
Precompiled header files can also easily be used\&. Precompiled header files
dramatically reduce the time that is required for compiling classes\(cq\& source
files\&. Refer to the \fBicmconf\fP(7) man\-page (in particular the description of
the \fIPRECOMP\fP define) for further details\&. 
.PP 
\fIIcmake\(cq\&s\fP  \fBC\fP\-like scripting language is described in the upcoming
sections of this man\-page:
.IP o 
\fBPREPROCESSOR DIRECTIVES\fP
.br 
\- supported preprocessor directives, like
\fI#include\fP and \fI#define\fP;
.IP o 
\fBDATA TYPES\fP
.br 
\- \fIint, list, string\fP, and \fIvoid\fP (for functions);
.IP o 
\fBPREDEFINED CONSTANTS\fP
.br 
\- like \fIO_FILE, OFF\fP, and \fIS_IFREG\fP;
.IP o 
\fBOPERATORS\fP
.br 
\- like \fI+, younger\fP, and casts
.IP o 
\fBFLOW CONTROL\fP
.br 
\- \fIif, for, while\fP, etc\&. (the \fIswitch\fP is not
available);
.IP o 
\fBPREDEFINED FUNCTIONS\fP
.br 
\- executing programs, changing directories,
operations on \fIstring\fP and \fIlist\fP type variables, etc\&.;
.IP o 
\fBUSER DEFINED FUNCTIONS\fP
.br 
\- at least \fImain\fP, with or without its
common parameters \fIargc, argv,\fP and \fIenvp\fP\&.

.PP 
.SH "OPTIONS"

.PP 
Where available, single letter options are listed between parentheses
beyond their associated long\-option variants\&. 
.PP 
The \fI\-\-\fP option is special:
.IP o 
\fI\-\-\fP: \fBicmake\fP arguments separator separating \fBicmake\fP arguments from
arguments passed to the \&.bim filenl()\&. Those arguments are passed
to the \&.bim file as\-is, and are available from the \fIlist argv\fP
parameter available from the \fBicmake\fP script\(cq\&s \fImain\fP function\(cq\&s
second parameter (see below at section \fBUSER DEFINED
FUNCTIONS\fP)\&. For some options (see below) the \fI\-\-\fP separator is
not required\&.

.PP 
\fBIcmake\fP supports various options, and only one of these can be specified
when \fBicmake\fP is invocated\&.
.PP 
.IP o 
\fB\-\-about\fP (\fB\-a\fP)
.br 
Show information about \fBicmake\fP and terminate\&.
.IP 
.IP o 
\fB\-\-compile\fP (\fB\-c\fP)
.br 
The \fBicmake\fP source file is compiled, generating a \&.bim file\&.
.IP 
.IP o 
\fB\-\-execute\fP (\fB\-e\fP)
.br 
Execute the \fBicmake\fP \&.bim file, given as \fBicmake\fP\(cq\&s first file
argument\&. Any additional arguments are passed to the \&.bim file as\-is,
and \fI\-\-\fP should not be specified\&.
.IP 
.IP o 
\fB\-\-force\fP (\fB\-f\fP)
.br 
The icmake source file is recompiled (even if the \fI\&.bim\fP file is
up\-to\-date) either when no other options are specified, or when in
combination with options \fI\-\-source\fP and \fI\-\-tmpbin\fP\&.
.IP 
.IP o 
\fB\-\-help\fP (\fB\-h\fP)
.br 
Provide usage info and terminate\&.
.IP 
.IP o 
\fB\-\-icm\-dep\fP (\fB\-d\fP)
.br 
Calls \fI/usr/lib/icmake/icm\-dep\fP, passing it all remaining
arguments\&. If no additional arguments are specified \fIicm\-dep\(cq\&s\fP
short usage information is shown to the std\&. output stream\&. See 
section \fBICM\-DEP\fP in \fBicbuild\fP(1)\(cq\&s man\-page for more information
about the \fIicm\-dep\fP support program\&. An overview of \fIicm\-dep\(cq\&s\fP
option follows below, next to this overview of \fBicmake\fP\(cq\&s options\&.
.IP 
.IP o 
\fB\-\-preprocess\fP (\fB\-p\fP)
.br 
The \fBicmake\fP source file is only preprocessed, and the preprocessed
file is written to \fBicmake\fP\(cq\&s second
file argument (by default \fI`source\(cq\&\&.pim\fP)\&.
.IP 
.IP o 
\fB\-\-source\fP (\fB\-i\fP)
.br 
The first argument is the \fBicmake\fP source file, the default binary
file is constructed if necessary\&. Any additional arguments are passed
to the \&.bim file as\-is, and \fI\-\-\fP should not be specified\&.
.IP 
.IP o 
\fB\-\-summary\fP (\fB\-F\fP)
.br 
The filenames and flags as well as an overview of all actions to
be performed by \fBicmake\fP are shown on the standard output stream\&.
.IP 
.IP o 
\fB\-t\fP \fItmpbim\fP
.br 
The \fItmpbim\fP argument following \fI\-t\fP is the name of a temporary
\&.bim file, which is removed after \fBicmake\fP\(cq\&s call\&. When \fI\&.\fP is
specified for \fItmpbim\fP then the default temporary directory,
followed by \fBicmake\fP\(cq\&s process\-id, followed by \fI\&.bim\fP is used\&.
.IP 
Following the name of the temporary \&.bim file the name of the \fBicmake\fP
source script must be specified\&. Any additional arguments are passed
to the \&.bim file as\-is, and \fI\-\-\fP should not be specified; After
setting the source script file\(cq\&s executable flag (\fIchmod +x
script\fP), and providing it with an initial line like this: 
.nf 

    #!/usr/bin/icmake \-t\&.
            
.fi 
the \fBicmake\fP script can directly be called:
.nf 

    script arg1 arg2 
            
.fi 
in which case the \fBicmake\fP script \fI`script\(cq\&\fP is executed while it
receives the arguments \fIscript arg1 arg2\fP\&.
.IP 
.IP o 
\fB\-T\fP \fIdirectory\fP
.br 
The specified directory is used to store temporary files\&. E\&.g\&., when
compiling an \fBicmake\fP script, the output of \fBicmake\fP\(cq\&s preprocessor is a
temporary file which is removed on exit\&. By default \fI/tmp\fP is used,
unless \fI/tmp\fP is not a writable directory, in which case the current
user\(cq\&s \fI$HOME\fP directory is used\&. Implicit temporary filenames
always start with the process id of the current \fBicmake\fP process\&.
.IP 
.IP o 
\fB\-\-version\fP (\fB\-v\fP)
.br 
Displays \fBicmake\fP\(cq\&s version number, and terminates\&.

.PP 
\fBIcmun\fP:
.PP 
\fIbimfile\fP:  binary \fBicmake\fP script file\&.
.PP 
.SH "ICM\-DEP invocation and options"

.PP 
To start its work, the dependencies\-analyzer \fIicm_dep\fP needs one
command\-line argument: \fIgo\fP\&. Any other argument results in \fIicm_dep\fP
performing a `dry run\(cq\&: it will perform all its duties (and verbose messages
are displayed as if \fIgo\fP had been specified), but no files (precompiled
headers or \fIUSE_ALL\fP files) will be touched or removed\&. If neither options
nor arguments are specified \fIicm_dep\fP writes its usage summary to the
standard output\&.
.PP 
Options of \fIicm\-dep\fP can be specified immediately following \fBicmake\fP\(cq\&s
\fI\-\-icm\-dep\fP option\&. The following options are recognized by \fIicm\-dep\fP:
.IP o 
\fB\-\-classes\fP=\fIfilename\fP (\fB\-c\fP)
.br 
By default, \fIicm\-dep\fP inspects dependencies of the classes whose
directories are mentioned in the file \fICLASSES\fP\&. If specified in the
\fBicmconf\fP(7) file, it will also consider dependencies of the
classes \fIParser\fP (directory \fIparser\fP) and \fIScanner\fP (directory
\fIscanner\fP), or it uses their actual names as defined in the
\fBicmconf\fP(7) file\&. Use this option if instead of \fICLASSES\fP another
file should be inspected\&.
.IP 
.IP o 
\fB\-\-help\fP (\fB\-h\fP)
.br 
\fIIcm\-dep\fP writes a summary of its usage to the standard output and
terminates\&.
.IP 
.IP o 
\fB\-\-icmconf\fP=\fIfilename\fP (\fB\-i\fP)
.br 
By default \fIicm\-dep\fP inspects the contents of an \fIicmconf\fP file,
looking for the \fIUSE_ALL\fP and \fIPRECOMP\fP specifications\&. Use this
option if instead of \fIicmconf\fP another file should be inspected\&.
.IP 
.IP o 
\fB\-\-mainih\fP=\fImainheader\fP (\fB\-m\fP)
.br 
The \fIicmconf\fP file uses the \fI#define IH\fP parameter to specify the
suffix of class header files that should be precompiled, their
filenames being equal to the names of the classes mentioned in the
\fICLASSES\fP file\&. \fICLASSES\fP does not specify a top\-level
directory\&. The name of the top\-level header file to precompile can be
specified using this option\&. By default it is \fImain\&.ih\fP\&. 
.IP 
.IP o 
\fB\-\-gch\fP
.br 
By default precompiled header files are inspected if \fIicmconf\fP
contains a \fI#define PRECOMP\fP specification\&. If it does not, but
precompiled headers should nonetheless be inspected, the option
\fI\-\-gch\fP can be specified\&. 
.IP 
.IP o 
\fB\-\-no\-gch\fP
.br 
By default precompiled header files are inspected if \fIicmconf\fP
contains a \fI#define PRECOMP\fP specification\&. If so, but precompiled
headers should \fInot\fP be inspected, the option \fI\-\-no\-gch\fP can be
specified\&.
.IP 
.IP o 
\fB\-\-no\-use\-all\fP
.br 
By default files named at the \fI#define USE_ALL\fP specification are
inspected if \fIicmconf\fP contains such a specification\&. If it does,
but the \fI`USE_ALL\(cq\&\fP files should not be inspected, this
option can be specified\&.
.IP 
.IP o 
\fB\-\-use\-all\fP=\fIfilename\fP
.br 
By default files named at the \fI#define USE_ALL\fP specification are
inspected if \fIicmconf\fP contains such a specification\&. If it does
not, but \fI`USE_ALL\(cq\&\fP files should nonetheless be inspected, this
option can be specified, together with the name of files (existing in
one or more directories that indicate that all the directory\(cq\&s source
files must be recompiled)\&.
.IP 
.IP o 
\fB\-\-verbose\fP (\fB\-V\fP)
.br 
This option can be specified multiple times\&. The number of times it is
specified defines \fIicm_dep\(cq\&s\fP verbosity\&. If none is specified,
\fIicm_dep\fP silently performs its duties\&. If specified once, then
\fIicm_dep\fP reports to the standard output what actions it performs;
if specified twice it reports the options it encountered; if specified
three times it also reports the class dependencies; if specified more
often it reports what files it encountered and what situations caused
it to make its decisions\&.
.IP 
.IP o 
\fB\-\-version\fP (\fB\-v\fP)
.br 
\fIIcm_dep\fP reports  its version number to the standard output and
terminates\&. 

.PP 
.SH "PREPROCESSOR DIRECTIVES"

.PP 
The following preprocessor directives are available:
.IP o 
comment:
.br 
standard \fBC\fP comment (all between \fI/*\fP and \fI*/\fP) as well as
comment\-to\-end\-of\-line (all line contents following \fI//\fP) are
ignored\&.
.IP 
.IP o 
Shell startup: The first line of the \fBicmake\fP\-script may start with
\fI#!path\fP, where \fIpath\fP defines the absolute location of the \fBicmake\fP
program\&. By making the script executable, it can be called without
explicitly calling \fBicmake\fP\&.  
.IP 
E\&.g\&., if the first line of an (executable) icmakefile \(cq\&icm\(cq\&
(without extension) contains
.nf 

            #!/usr/bin/icmake \-i
        
.fi 
then \fIicm\fP may be issued as a command, thus executing
.nf 

            /usr/bin/icmake \-i icm \&.\&.\&.
        
.fi 
Alternatively, 
.nf 

            #!/usr/bin/icmake \-t /tmp/icm
        
.fi 
may be used, resulting in the execution of
.nf 

            #!/usr/bin/icmake \-t /tmp/icm icm \&.\&.\&.
        
.fi 
In this case the binary file is removed on exit\&.
.IP 
.IP o 
\fI#include \(dq\&filename\(dq\&\fP
.br 
The file \fIfilename\fP is included at the location of the directive
.IP 
.IP o 
\fI#include <filename>\fP
.br 
The file \fIfilename\fP is included at the location of the \fI#include\fP
directive; \fIfilename\fP is searched in the colon\-separated directories
specified by the \fIIM\fP environment variable\&. The first occurrence of
\fIfilename\fP in the directories specified by the \fIIM\fP environment
variable is used\&.
.IP 
.IP o 
\fI#define identifier [definition]\fP
.br 
The text \fIidentifier\fP will be replaced by \fIdefinition\fP\&. The
definition may contain references to already defined identifiers,
using the \fI${identifier}\fP format\&. If the \fI${identifier}\fP hasn\(cq\&t
been defined (yet), the text \fI${identifier}\fP is literally kept\&. To
prevent infinite recursion at most 100 \fI${identifier}\fP replacements
are allowed\&.
.IP 
Definitions continue at the next line if the last character on a line
is a backslash (\fI\e\fP)\&.  (which is not included in the
definition)\&. The preprocessor concatenates double\-quuted strings, and
double quoted strings may not span multiple lines\&. Multiple blanks
(outside of double quoted strings) in definitions are contracted to a
single blank space\&.
.IP 
The definition following the \fI#define\(cq\&s\fP identifier is optional\&. If
omitted, the macro is defined, so it can be used in \fI#if(n)def\fP
directives (see below), but they are not replaced by any text in
\fBicmake\fP code statements\&.
.IP 
.IP o 
\fI#ifdef identifier\fP
.br 
If the \fIidentifier\fP macro was defined the next block of code (until a
matching \fI#else\fP or \fI#endif\fP directive was read) is
byte\-compiled\&. Otherwise, the block of code is ignored\&.
.IP 
.IP o 
\fI#ifndef identifier\fP
.br 
If the \fIidentifier\fP macro was \fInot\fP defined the next block of code
(until a matching \fI#else\fP or \fI#endif\fP directive was detected) is
byte\-compiled\&. Otherwise, the block of code is ignored\&.
.IP 
.IP o 
\fI#else\fP
.br 
Terminates a \fI#ifdef\fP and \fI#ifndef\fP directive, reversing the
acceptance decision about the following code\&. Only one \fI#else\fP
directive can be associated with \fI#if(n)def\fP directives\&.
.IP 
.IP o 
\fI#endif\fP
.br 
Terminates the preprocessor block starting at the matching 
\fI#ifdef\fP, \fI#ifndef\fP or \fI#else\fP directive\&. The \fI#endif\fP
directory and its matching \fI#if(n)def\fP directive must be specified
in the same file\&.
.IP 
.IP o 
\fI#undef identifier\fP 
.br 
Remove \fIidentifier\fP from the set of defined symbols\&. This does not
affect the specification of any previously defined symbols in which
\fIidentifier\(cq\&s\fP definition has been used\&. If \fIidentifier\fP hasn\(cq\&t
been defined a warning is issued\&.

.PP 
.SH "DATA TYPES"

.PP 
\fBIcmake\fP supports these data types:
.IP o 
\fIASCII character constants\fP
.br 
ASCII character constants consist of one character, surrounded by
single or double quotes\&. Single characters (e\&.g\&., \fI\(cq\&a\(cq\&\fP) represent
the character itself\&. Standard escape sequences (e\&.g\&., \fI\(cq\&\en\(cq\&\fP) are
supported and represent their standard converted value (e\&.g\&., \fI\(cq\&\en\(cq\&\fP
represents ascii value 10 (decimal))\&. Non\-standard escape sequences
(e\&.g\&., \fI\(cq\&\ex\(cq\&\fP) represent the ascii character following the escape
character (so \fI\(cq\&\ex\(cq\&\fP equals \fI\(cq\&x\(cq\&\fP)\&. Escape sequences consisting of
three octal digits represent the ascii character corresponding to the
octal value modulo 256 (e\&.g\&., \fI\(cq\&\e123\(cq\&\fP)\&. Escape sequences consisting
of an x followed by two hexadecimal digits represent the ascii
character corresponding to the hexadecimal value (e\&.g\&., \fI\(cq\&\exa4\(cq\&\fP)\&.
.IP 
.IP o 
\fIint\fP
.br 
Integral values, ranging from \fI\-0x8000\fP through \fI0x7fff\fP\&. \fIint\fP
constants may be specified as decimal numbers (starting with digits 1
through 9), octal numbers (starting with 0, followed by one or more
octal digits) hexadecimal numbers (starting with 0x, followed by one
or more hexadecimal digits) or as \fIASCII\fP character constants\&.
.IP 
.IP o 
\fIstring\fP
.br 
Text variables\&. String constants are delimited by double
quotes\&. Multiple string constants may be concatenated, but a single
string constant may not span multiple lines\&. String constants
separated by white space only (i\&.e\&., blanks, newlines, comment) are
concatenated and represent one single string constant\&. To indicate an
end\-of\-line in a string constant use the \fI\en\fP escape sequence\&.
.IP 
ASCII character constants surrounded by double quotes can also be used
in arithmetic expressions if one of the operands is an \fIint\fP\&. The
single character string constant \fImust\fP be a constant, and cannot be
a \fIstring\fP variable\&.
.IP 
Likewise, ASCII character constants surrounded by single quotes may be
used in situations where a string operand is expected\&.
.IP 
.IP o 
\fIlist\fP
.br 
A data structure containing a series of individually accessible
\fIstring\fP values\&. When a list contains elements, its first element is
indicated by index 0\&.
.IP 
.IP o 
\fIvoid\fP
.br 
Used with function definitions to indicate that the function does not
return a value\&.

.PP 
Variables can be defined at the global level as well as at any local level
inside functions\&. When defined inside functions, the standard \fBC\fP scoping
and visibility rules apply\&. E\&.g\&., local variables can only be used in their
own or in more deeply nested blocks, their visibility is masked in more deeply
nested blocks by defining an identically named variable inside those more
deeply nested blocks\&. Variables are strongly typed, and cannot have
type \fIvoid\fP\&.
.PP 
Variables may be initialized when they are defined\&. Initializations are
expressions, that can use pre\- or user\-defined functions, constant values, and
values of variables that are visible at the point of definition\&.
.PP 
.SH "PREDEFINED CONSTANTS"

.PP 
The following constants are predefined by \fBicmake\fP\&. All are constant \fIint\fP 
values:
.TS 
 tab(~);






















---
lll
---
lll
lll
lll
lll
---
lll
lll
---
lll
lll
---
lll
lll
lll
lll
lll
lll
---
c.
symbol~value~intended for
O_ALL~8~makelist
O_DIR~2~makelist
O_FILE~1~makelist
O_SUBDIR~4~makelist
OFF~0~echo
ON~1~echo
P_CHECK~0~system calls
P_NOCHECK~1~system calls
S_IEXEC~32~stat
S_IFCHR~1~stat
S_IFDIR~2~stat        
S_IFREG~4~stat
S_IREAD~8~stat        
S_IWRITE~16~stat

.TE 

.PP 
The following constants are architecture dependent:
.TS 
 tab(~);












--
ll
--
ll
ll
ll
ll
ll
ll
ll
--
c.
symbol~1 when defined on the platform, otherwise 0
unix~Unix, usually with GNU\(cq\&s gcc compiler
UNIX~may alternatively be available
linux~x86 running Linux (usually with gcc)
LINUX~may alternatively be available
M_SYSV, M_UNIX~x86 running SCO/Unix
_POSIX~_SOURCE   Unix with Posix compliant compiler
__hpux~HP\-UX, with the native HP compiler

.TE 

.PP 
.SH "OPERATORS"

.PP 
\fBint\-typed operand(s):\fP
.PP 
All \fBC\fP operators are available (except for pointer operators, as \fBicmake\fP
does not support pointers)\&. They operate like their \fBC\fP\-programming language
counterparts\&.
.PP 
\fBstring\-typed operand(s):\fP
.PP 
For \fIstring\fP type variables and/or constants the following
operators are available (\fIa\fP and \fIb\fP represent \fIstring\fP variables or
constants): 
.PP 
.IP o 
\fIa + b\fP: returns a new \fIstring\fP value containing the concatenation of
\fIstring\fP values \fIa\fP and \fIb\fP\&. Note that \fIstring\fP constants may be
directly concatetated (without using the \fI+\fP operator), e\&.g\&., the following
two lines both define the string \fI\(dq\&hello world\(dq\&\fP:
.nf 

\(dq\&hello \(dq\&   \(dq\&world\(dq\&
\(dq\&hello \(dq\& + \(dq\&world\(dq\&
        
.fi 

.IP 
.IP o 
\fIa += b\fP: \fIa\fP must be a  \fIstring\fP variable, to which the \fIstring\fP
variable or value \fIb\fP is appended\&.
.IP 
.IP o 
string comparisons: operators \fI== != <= >= < > !=\fP and \fI==\fP may
be applied to \fIstring\fP values or variables, returning 1 if the comparison
succeeds, otherwise 0\&. Comparison is case sensitively, and follows the
ordering or characters as defined in the \fIASCII\fP character set\&.
.IP 
.IP o 
\fI!a\fP: the boolean \fI!\fP (not) operator returns 1 if the \fIstring a\fP is
empty, otherwise 0 is returned\&.
.IP 
.IP o 
\fIa younger b, a newer b\fP: returns 1 if file \fIa\fP is more recent than
file \fIb\fP\&. E\&.g\&., \fI\(dq\&source\&.cc\(dq\& newer \(dq\&source\&.o\(dq\&\fP\&. The files \fIa\fP and \fIb\fP
do not have to exist: if both don\(cq\&t exist 0 is returned; if \fIb\fP doesn\(cq\&t
exist, 1 is returned; if \fIa\fP doesn\(cq\&t exist 0 is returned; if they are
equally old 0 is returned\&. (the \fIexists()\fP predefined function (see below,
section \fBPREDEFINED FUNCTIONS\fP) can be used to test explicitly whether a file
exists)\&.
.IP 
.IP o 
\fIa older b\fP: turns 1 if file \fIa\fP is older than file \fIb\fP\&. E\&.g\&.,
\fI\(dq\&libprog\&.a\(dq\& older \(dq\&source\&.o\(dq\&\fP\&. The files \fIa\fP and \fIb\fP do not have to
exist: if both don\(cq\&t exist 0 is returned; if \fIa\fP doesn\(cq\&t exist, 1 is
returned; if \fIb\fP doesn\(cq\&t exist 0 is returned; if they are equally old 0 is
returned\&.
.IP 
.IP o 
\fI[]\fP: the index operator retrieves a character from a string variable
or constant: it returns a string as an \fIrvalue\fP\&. Therefore, the following
statement compiles OK:
.nf 

    // assume str1 and str2 are strings
str1 = str2[3];
        
.fi 
but the following statement won\(cq\&t compile:
.nf 

str2[3] = \(dq\&a\(dq\&; 
        
.fi 

.IP 
An empty string is returned if an invalid index value is provided\&.
.IP 
.IP o 
The `backtick` operator (\fI`string cmd`\fP)
.br 
A string placed between two backticks is executed by the \fIpopen\fP(3)
function\&. The standard output gererated by the command that is stored
in the string argument is returned as a list\&. An empty list indicates
that the command could not be executed\&. A command that could be
executed but did not produce any output returns a list containing one
empty element\&. The command\(cq\&s standard error stream output is not
collected by the backtick operator\&. However, standard shell
redirection could be used to collect the standard error stream\(cq\&s
output\&. Example:
.nf 

printf(`\(dq\&ls\(dq\&`);     // prints the elements in 
                    // the current directory
            
.fi 
The predefined function \fIeval(string cmd)\fP behaves exactly like the
backtick operator: they are synonyms\&.

.PP 
\fBlist\-typed operand(s):\fP
.PP 
For \fIlist\fP type variables and/or values the following
operators are available:
.IP o 
\fIa + b\fP: returns a new \fIlist\fP value containing the concatenation of
\fIlist\fP values \fIa\fP and \fIb\fP\&. This is \fInot\fP a set operation: if an
element appears both in \fIa\fP and in \fIb\fP, they will appear twice in the
resulting list (set\-addition is provided by the built\-in function
\fIlistunion\fP)\&.
.IP 
.IP o 
\fIa \- b\fP: returns a new \fIlist\fP value containing the elements in \fIa\fP
that are not present in \fIb\fP\&. This \fIis\fP a set\-difference operation: the
returned list contains all elements in \fIa\fP that are not elements of \fIb\fP\&.
.IP 
.IP o 
\fIa += b\fP: elements in \fIb\fP are added to the elements in \fIa\fP, which 
must be a  \fIlist\fP variable\&.  This is \fInot\fP a set operation\&.
.IP 
.IP o 
\fIa \-= b\fP: elements in \fIb\fP are removed from the elements in \fIa\fP,
which must be a \fIlist\fP variable\&.  This \fIis\fP a set operation: all elements
of \fIa\fP that are found in \fIb\fP are removed from \fIa\fP\&.
.IP 
.IP o 
list equality comparisons: operators \fI!=\fP and \fI==\fP may be applied
to \fIlist\fP values or variables\&. Operator \fI==\fP returns 1 if both lists have
element\-by\-element identical elements, otherwise 0 is returned\&. Operator
\fI!=\fP reverses the result of \fI==\fP\&.
.IP 
.IP o 
\fI!a\fP: the boolean \fI!\fP operator returns 1 if the \fIlist a\fP is
empty, otherwise 0 is returned\&.
.IP 
.IP o 
\fI[]\fP: the index operator retrieves a list element from a list variable:
it returns a string as an \fIrvalue\fP\&. Therefore, the following statement
compiles OK:
.nf 

    // assume lst is a list, str is a string
str = lst[3];
        
.fi 
but the following statement won\(cq\&t compile:
.nf 

lst[3] = str;
        
.fi 
An empty string is returned if an invalid index value is provided\&.

.PP 
\fBCasting:\fP
.PP 
Type\-casts may be performed using the standard \fBC\fP cast\-operator to
cast:
.IP o 
Strings to ints and vice versa (\fI(int)\(dq\&123\(dq\&, (string)55\fP)
.IP o 
Strings to lists (\fIlist lst = (list)\(dq\&hello\(dq\&\fP)

.PP 
.SH "FLOW CONTROL"

.PP 
\fBIcmake\fP offers the following subset of \fBC\fP\(cq\&s statements\&. They can be
used as in the \fBC\fP programming language\&.
.IP o 
\fIexpression ;\fP
.br 
The plain expression statement;
.IP 
.IP o 
The compound statement 
.br 
Variables of any type may be defined and initialized anywhere inside
any compound statement\&. The \fIvisibility\fP of a variable starts at its
point of definition\&.
.IP 
.IP o 
\fIif (condition) statement\fP
.br 
Inside the condition a variable may be defined and initialized\&. E\&.g,
.nf 

    if (string str = getText())
        process(str);
            
.fi 
In this example, \fIprocess\fP is not called if \fIgetText()\fP returns an
empty string\&. The variable \fIstr\fP does not exist either before or
after the \fIif\fP statement\&.
.IP 
.IP o 
\fIif (condition) statement else statement\fP
.br 
As with the previous statement, inside the condition a variable may be
defined and initialized\&. 
.IP 
.IP o 
\fIfor (init; condition; increment) statement\fP
.br 
Variables (of a single type) may be initialized (and optionally be
defined) in the \fIinit\fP section\&. The \fIinit\fP, \fIcondition\fP and
\fIincrement\fP sections may remain empty\&. The empty condition section
is interpreted as `always \fItrue\fP\(cq\&\&.
.IP 
.IP o 
\fIwhile (condition) statement\fP
.br 
Inside the condition a variable may be defined and initialized\&.
.br 
A complementary  \fIdo \&.\&.\&. while()\fP statement is not available\&. Note
that defining a variable, using an initialization expression means
that the initialization expressing is executed at each iteration of the
\fIwhile\fP statement\&. So the following statement will never end, and
will display a never ending stream of values 10:
.nf 

while (int x = 10)
    printf(x\-\-, \(dq\&\en\(dq\&);
        
.fi 

.IP 
.IP o 
\fIreturn;\fP, and \fIreturn expression;\fP
.br 
Plain \fIreturn\fP statements can be used in \fIvoid\fP functions,
and \fIreturn expression\fP statements are used in other type of 
functions\&. The function \fImain\fP has return type \fIvoid\fP and so in
\fImain\fP only plain \fIreturn\fP statements can be used\&. 
By default an \fBicmake\fP script\(cq\&s exit value equals 0\&. Use the built\-in
function \fIexit\fP (see below) to specify any other exit value\&. 
.IP 
\fBBe advised: \fP the behavior of non\-void functions not returning
values is undefined\&.
.IP 
.IP o 
\fIbreak\fP
.br 
Leaves \fIfor\fP and \fIwhile\fP statements, overruling the statement\(cq\&s
condition\&.
.IP 
.IP o 
\fIcontinue\fP
.br 
Continues with the next iteration of a \fIfor\fP or \fIwhile\fP
statement\&.
.IP 
.IP o 
\fIexit(expression)\fP
.br 
Ends the execution of an \fBicmake\fP\-script\&. The \fIexpression\fP must
evaluate to an \fIint\fP value, which becomes the script\(cq\&s exit value\&.

.PP 
.SH "PREDEFINED FUNCTIONS"

.PP 
\fBIcmake\fP offers the following predefined functions, which can be used
anywhere in \fBicmake\fP scripts\&. The following overview is ordered alphabetically
by function name\&.
.PP 
.IP o 
\fIvoid arghead(string h)\fP
.br 
Helper function of \fIexec()\fP (see also below at \fIexec()\fP):
defines the `argument head\(cq\&, to be used with \fIexec()\fP\&. By default,
the `argument head\(cq\& is an empty string\&.
.IP 
.IP o 
\fIvoid argtail (string t)\fP
.br 
Helper function of \fIexec()\fP (see also below at \fIexec()\fP): defines
the `argument tail\(cq\&, to be used with \fIexec()\fP\&. By default, the
`argument tail\(cq\& is an empty string\&.
.IP 
.IP o 
\fIint ascii(string s)\fP
.br 
Returns the first character of \fIs\fP as an int; e\&.g\&.,
\fIascii(\(dq\&A\(dq\&)\fP returns 65;
.IP 
.IP o 
\fIstring ascii(int i)\fP
.br 
Returns \fIi\fP as a string, e\&.g\&., \fIascii(65)\fP returns the string
\fI\(dq\&A\(dq\&\fP;
.IP 
.IP o 
\fIstring change_base(string file, string newbase)\fP
.br 
Changes the basename of \fIfile\fP, returns the changed name\&. E\&.g, 
\fIchange_base(\(dq\&/path/demo\&.im\(dq\&, \(dq\&out\(dq\&)\fP returns \fI\(dq\&/path/out\&.im\(dq\&\fP;
.IP 
.IP o 
\fIstring change_ext(string file, string newext)\fP
.br 
Changes the extension of \fIfile\fP, returns the changed name\&. E\&.g, 
\fIrss_changeExt(\(dq\&source\&.cc\(dq\&, \(dq\&o\(dq\&)\fP returns \fI\(dq\&source\&.o\(dq\&\fP;
.IP 
.IP o 
\fIstring change_path(string file, string newpath)\fP
.br 
Changes the path specification of \fIfile\fP, returns the changed name\&.
E\&.g, \fIchange_path(\(dq\&tmp/binary\(dq\&, \(dq\&/usr/bin\(dq\&)\fP returns 
\fI\(dq\&/usr/bin/binary\(dq\&\fP\&. Note that the \fI/\fP\-separator is inserted if
required\&. 
.IP 
.IP o 
\fIstring chdir(string newdir)\fP
.br 
Changes the script\(cq\&s working directory, returns the previous dir as an
absolute path\&.
.IP 
Use \fIchdir(\(dq\&\&.\(dq\&)\fP to obtain the current working directory,
\fIchdir(\(dq\&\(dq\&)\fP may be used to obtain the startup working directory
(this functionality was broken in releases before than 7\&.00, but is
now operational)\&. The function terminates the \fBicmake\fP\-script if the
specified \fInewdir\fP does not exist\&.
.IP 
.IP o 
\fIstring chdir(int checking, string newdir)\fP
.br 
Same functionality as the previous function, but by specifying
\fIchecking\fP as \fIP_NOCHECK\fP\&. the function won\(cq\&t terminate the
script\&. Rather, it will return the script\(cq\&s current working directory\&.
.IP 
.IP o 
\fIcmdhead(string h)\fP
.br 
Helper function of \fIexec()\fP (see also below at \fIexec()\fP):
Defines a `command head\(cq\&, to be used with \fIexec()\fP\&. By default,
the `command head\(cq\& is an empty string\&.
.IP 
.IP o 
\fIcmdtail(string t)\fP
.br 
Helper function of \fIexec()\fP (see also below at \fIexec()\fP):
Defines a `command tail\(cq\&, to be used with \fIexec()\fP\&. By default,
the `command tail\(cq\& is an empty string\&.
.IP 
.IP o 
\fIecho(int opt)\fP
.br 
Controls echoing of called programs (and their arguments), specify
\fIOFF\fP if echoing is not requested\&. By default \fIecho(ON)\fP is used\&.
.IP 
.IP o 
\fIstring element(int index, list (or string) var)\fP
.br 
Acts identical to the index operator: refer to the index (\fI[]\fP)
operator in the section \fBOPERATORS\fP\&.
.IP 
.IP o 
\fIlist eval(string str)\fP
.br 
This function acts identically to the backtick operator\&. The example
provided with the backtick operator could therefore also
have been written like this:
.nf 
 
printf(eval(\(dq\&ls\(dq\&)); // prints the elements in the current 
                    // directory 
        
.fi 

.IP 
.IP o 
\fIexec(string cmd, \&.\&.\&.)\fP
.br 
Executes command with arguments\&. Each argument will be prefixed by
\fIarghead()\fP\(cq\&s argument and postfixed by \fIargtail()\fP\(cq\&s
argument\&. Note that no blanks are inserted between \fIarghead()\fP\(cq\&s
contents, the argument proper, and \fIargtail()\fP\(cq\&s argument\&. All thus
modified arguments are concatenated, this time separated by single
blanks, and then \fIcmdhead()\fP\(cq\&s contents are inserted between the
command and the first argument (on either side delimited by single
blanks) and \fIcmdtail()\fP\(cq\&s contents are appended to the arguments
(again, separated by a single blank)\&. \fIPATH\fP is searched to locate
\fIcmd\fP\&. 0 is returned\&.
.IP 
.IP o 
\fIexec(int checkcmd, string cmd, \&.\&.\&.)\fP
.br 
Same functionality as the previous function, but by specifying
\fIchecking\fP as \fINOT_CHECKED\fP the function won\(cq\&t terminate the
script\&. Rather, it will return the called command\(cq\&s exit status, or
\fI0x7f00\fP if the command wasn\(cq\&t found\&.
.IP 
.IP o 
\fIexecute(string cmd, string cmdhd,
string arghd, \&.\&.\&., string argtl, string cmdtl)\fP
.br 
Same as \fIexec()\fP, but command head/tail and argument head/tail must
be specified\&.
.IP 
The actually executed command starts with \fIcmd\fP, followed by
\fIcmdhd\fP\&. Next is a series of arguments follows, each enclosed by
\fIarghd\fP and \fIargtl\fP\&. The command terminates with \fIcmdtl\fP\&. 0 is
returned
.IP 
.IP o 
\fIexecute(int checking, string cmd, string cmdhd,
string arghd, \&.\&.\&., string argtl, string cmdtl)\fP
.br 
Same functionality as the previous function, but by specifying
\fIchecking\fP as \fINOT_CHECKED\fP the function won\(cq\&t terminate the
script\&. Rather, it will return the called command\(cq\&s exit status, or
\fI0x7f00\fP if the command wasn\(cq\&t found\&.
.IP 
.IP o 
\fIint exists(string file)\fP
.br 
Returns a non\-zero value if \fIfile\fP exists, otherwise 0 is returned\&. 
.IP 
.IP o 
\fIlist fgets(string file, list offset)\fP
.br 
\fBNOTE:\fP in \fBicmake\fP version 8\&.00\&.00 the prototype of this function was
changed from \fIlist fgets(string file, int offset)\fP to
\fIlist fgets(string file, list offset)\fP\&.
.IP 
The next line found at the offset contained in \fIoffset\fP is read from
\fIfile\fP\&. Pass an empty list to \fIfgets\fP to read \fIfile\fP from its
beginning\&.
.IP 
It returns a list containing as its first element the contents of the
read line (without the \fI\en\fP line terminator), as its second element
the line\(cq\&s terminator `\fI\en\fP\(cq\& (if encountered), and as its third
element the string \fIOK\fP if a line was successfully read, \fIFAIL\fP if
reading from file failed\&. When reading at EOF an empty list is
returned\&. The returned list may contain additional elements, which are
internally used by \fIfgets\fP when reading the next line\&.
.IP 
To read multiple lines, start by passing an empty list as \fIgets\(cq\&s\fP
second argument\&. To read subsequent lines, pass the previously
returned list to \fIfgets\(cq\&s\fP second argument\&.
.IP 
Here is an example showing how to read a complete file:
.nf 

list ret;
while (1)
{
    ret = fgets(\(dq\&filename\(dq\&, ret);
    if (!ret)
        break;
    process(ret[0], ret[1]);
}
            
.fi 

.IP 
.IP o 
\fIint fprintf(string filename, \&.\&.\&.)\fP
.br 
Appends all (comma separated) arguments to the file
\fIfilename\fP\&. Returns the number of printed arguments\&.
.IP 
.IP o 
\fIint fprintf(string filename, string format, \&.\&.\&.)\fP
.br 
Appends all (comma separated) arguments to the file
\fIfilename\fP\&. Returns the number of printed arguments\&.
.IP 
If \fIformat\fP contains placeholders %1 \&.\&. %n the output is formatted
(see also \fIstrformat\fP)\&. Note that in this case argument counting
(also) starts beyond the format string: the first argument following
\fIformat\fP is referred to as \fI%1\fP\&.
.IP 
.IP o 
\fIstring get_base(string file)\fP
.br 
Returns the base name of \fIfile\fP\&. The base name is the file without
its path prefix and without its extension\&. The extension is all
information starting at the final dot in the filename\&. If no final dot
is found, the file name is the base name\&. E\&.g\&., the base name of
\fIa\&.b\fP equals \fIa\fP, the base name of \fIa\&.b\&.c\fP equals \fIa\&.b\fP, the
base name of \fIa/b/c\fP equals \fIc\fP\&. 
.IP 
.IP o 
\fIstring getch()\fP
.br 
Returns the next pressed key as a string (pressing `Enter\(cq\& is not
required)\&.
.IP 
.IP o 
\fIstring get_dext(string file)\fP
.br 
Returns the extension of \fIfile\fP, including the separating dot\&. The
extension is all information starting at the filename\(cq\&s final dot\&.
.IP 
If no final dot is found, an empty string is returned\&.
.IP 
.IP o 
\fIlist getenv(string envvar)\fP
.br 
Returns the value of environment variable \fIenvvar\fP in a list
containing two elements:
.IP 
the first element indicates whether the environment variable was
defined (value \fI\(dq\&1\(dq\&\fP) or not (value \fI\(dq\&0\(dq\&\fP);
.br 
the second element indicates the value of the environment variable\&.
.IP 
Enivironment variables are of the form \fIvariable=value\fP, and if
defined the list\(cq\&s second element contains \fIvalue\fP\&. If the value is
empty, the variable is defined, but has no text associated with it\&.
.IP 
.IP o 
\fIstring get_ext(string file)\fP
.br 
Returns the extension of \fIfile\fP, except for the separating dot\&. The
extension is all information starting at the final dot in the
filename\&.
.IP 
If no final dot is found, an empty string is returned\&.
.IP 
.IP o 
\fIint getpid()\fP
.br 
Returns the process\-id of the icmake byte code interpreter
\fBicm\-exec\fP\&.
.IP 
.IP o 
\fIstring gets()\fP
.br 
Returns the next line read from the keyboard as a \fIstring\fP\&. The line
entered on the keyboard must be terminated by an `Enter\(cq\& key, which is
not stored in the returned string\&.
.IP 
.IP o 
\fIstring get_path(string file)\fP
.br 
Returns the path\-prefix of \fIfile\fP\&. The path prefix is all information
up to (and including) the final directory separator (which is,
depending on the operating system, a forward\- or backslash)\&.
.IP 
If no path is found, an empty strring is returned\&.
.IP 
.IP o 
\fIint listfind(list lst, string str)\fP
.br 
Returns the first index in \fIlst\fP where the string \fIstr\fP is found,
or \-1 if \fIlst\fP does not contain \fIstr\fP\&.
.IP 
.IP o 
\fIint listlen(list l)\fP
.br 
Returns the number of elements in \fIlist\fP\&.
.IP 
.IP o 
\fIlist listunion(list lhs, list rhs)\fP
.br 
Returns a list containing the union of the elements in \fIlhs\fP and
\fIrhs\fP\&.
.IP 
.IP o 
\fIlist listunion(list lst, string str)\fP
.br 
Returns a list containing the union of the elements in \fIlst\fP and
\fIstr\fP\&.
.IP 
.IP o 
\fIlist makelist(string mask)\fP
.br 
Returns a list of all files matching \fImask\fP\&. E\&.g\&.,
\fImakelist(\(dq\&*\&.c\(dq\&)\fP returns a list containing all files ending in
\fI\&.c\fP\&. 
.IP 
.IP o 
\fIlist makelist(type, string mask)\fP
.br 
Same as the previous function, but the type of the directory elements
may be specified as its first argument:
.TS 
 tab(~);










ll

ll
ll
ll
ll

c.
symbol~meaning~
O_ALL~obtain all directory entries~
O_DIR~obtain all directories, including \&. and \&.\&.~
O_FILE~obtain a list of files~
O_SUBDIR~obtain all subdirectories~

.TE 
Note that the pattern \fI*\fP will not match hidden entries under Unix\-type
operating systems\&. Use \fI\&.*\fP for that\&.
.IP 
.IP o 
\fIlist makelist(string mask, newer, string comparefile)\fP
.br 
Returns list of all files matching mask which are newer
than a provided comparefile\&. Operator \fIyounger\fP may be used instead
of \fInewer\fP\&. Note that \fInewer\fP and \fIyounger\fP are operators, not
strings\&. 
.IP 
.IP o 
\fIlist makelist([int = IS_FILE,] string mask, newer,
string comparefile)\fP
.br 
Same as the previous function, but \fItype\fP may be specified as in
\fIlist makelist(type, string mask)\fP\&.
.IP 
.IP o 
\fImakelist(string mask, older, string comparefile)\fP
.br 
See above; returns a list of files that are older than the 
comparefile\&.
.IP 
.IP o 
\fImakelist(type, string mask, older, string comparefile)\fP
.br 
Same as the previous function, but \fItype\fP may be specified as in
\fIlist makelist(type, string mask)\fP\&.
.IP 
.IP o 
\fIint printf(\&.\&.\&.)\fP
.br 
Shows all (comma separated) arguments to screen (i\&.e\&., the standard
output stream)\&. Returns the number of printed arguments\&.
.IP 
.IP o 
\fIint printf(string format, \&.\&.\&.)\fP
.br 
Shows all (comma separated) arguments to screen (i\&.e\&., the standard
output stream)\&. Returns the number of printed arguments (the
\fIformat\fP string counts as one argument)\&.
.IP 
If \fIformat\fP contains placeholders %1 \&.\&. %n the output is 
formatted (see also \fIstrformat\fP)\&.
.IP 
.IP o 
\fIint putenv(string envvar)\fP
.br 
Adds \fIenvvar\fP to the current (\fBicmake\fP) environment Use the format:
\(dq\&VAR=value\(dq\&\&. Returns 0\&.
.IP 
.IP o 
\fIstring resize(string str, int newlength)\fP 
Returns a copy of string \fIstr\fP, resized to \fInewlength\fP characters\&.
If \fInewlength\fP is negative then an empty string is returned, if
\fInewlength\fP exceeds \fIstr\(cq\&s\fP length then the newly added characters
are initialized to blank spaces\&.
.IP 
.IP o 
\fIint sizeof(list l)\fP
.br 
Deprecated: use \fIlistlen\fP\&.
.IP 
.IP o 
\fIint sizeoflist(list l)\fP
.br 
Deprecated: use \fIlistlen\fP\&.
.IP 
.IP o 
\fIlist stat(string entry)\fP
.br 
Returns \fBstat\fP(2) information of directory entry \fIentry\fP as a
list\&. The returned list has two elements: element 0 is the
\fIattribute value\fP, element 1 contains the size of the file\&.
.IP 
Attributes are  returned as bit\-flags, composed from the
following predefined constants: 
.nf 

S_IFCHR     S_IFDIR     S_IFREG
S_IREAD     S_IWRITE    S_IEXEC
        
.fi 
See the \fBstat\fP(2) manual page for the meanings of these constants\&.
.IP 
.IP o 
\fIlist stat(checking, string entry)\fP
.br 
Same as the previous function, but by specifying \fIchecking\fP as
\fIP_NOCHECK\fP the function won\(cq\&t terminate the script\&. Rather, it 
returns \fBstat\fP(2)\(cq\&s return value\&.
.IP 
.IP o 
\fIint strchr(string str, string chars)\fP
.br 
Returns the first index in \fIstr\fP where any of the characters in
\fIchars\fP is found, or \-1 if \fIstr\fP does not contain any of the
characters in \fIchars\fP\&.
.IP 
.IP o 
\fIint strlen(string str)\fP
.br 
Returns the number of characters in \fIstr\fP (not counting the final 0)\&.
.IP 
.IP o 
\fIint strfind(string haystack, string needle)\fP
.br 
Returns index in \fIhaystack\fP where \fIneedle\fP is found, or \-1 if
\fIneedle\fP is not contained in \fIhaystack\fP\&.
.br 
\fBThis function was
called strstr() in versions before 7\&.00\fP\&.
.IP 
.IP o 
\fIint strformat(string format,\&.\&.\&.)\fP
.br 
Returns a formatted string using placeholders %1 \&.\&. %2 to address
arguments following format\&.
.br 
Example:
.br 
.nf 

void main()
{
    int i = 10;
    int j = 20;
    string s1;
    string s2;
                                    // traditional approach:
    s1 = (string)i + \(dq\& \(dq\& + (string)j + \(dq\& \(dq\& + (string)i;
                                    // using strformat:  
    s2 = strformat(\(dq\&%1 %2 %1\(dq\&, i, j);
    printf(\(dq\&s1 = %1, s2 = %2\en\(dq\&, s1, s2);
}
        
.fi 

.IP 
.IP o 
\fIstring strlwr(string s)\fP
.br 
Returns a lower\-case duplicate of \fIs\fP\&.
.IP 
.IP o 
\fIlist strtok(string str, string separators)\fP
.br 
Returns a list containing all substrings of \fIstr\fP separated by one
or more (consecutive) characters in \fIseparators\fP\&. E\&.g\&.,
\fIstrtok(\(dq\&hello icmake\(cq\&s+world\(dq\&, \(dq\& +\(dq\&)\fP returns the list containing
the three strings \fI\(dq\&hello\(dq\&\fP, \fI\(dq\&icmake\(cq\&s\(dq\&\fP, and \fI\(dq\&world\(dq\&\fP\&.
.IP 
.IP o 
\fIstring strupr(string s)\fP
.br 
Returns an upper\-case duplicate of \fIs\fP\&.
.IP 
.IP o 
\fIstring substr(string text, int offset, int count)\fP
.br 
Returns a substring of \fItext\fP, starting at \fIoffset\fP, consisting of
\fIcount\fP characters\&. If \fIoffset\fP exceeds (or equals) the string\(cq\&s
size or if \fIcount <= 0\fP, then an empty string is returned\&. If
\fIoffset\fP is less than 0 then \fIoffset = 0\fP is used\&. 
.IP 
.IP o 
\fIint system(string command)\fP
.br 
Executes \fIcommand\fP\&. The return value indicates the executed
command\(cq\&s exit value\&. The string \fIcommand\fP may contain redirection
and/or piping characters\&.
.IP 
.IP o 
\fIint system(int checking, string command)\fP
.br 
Same functionality as the previous function, but by specifying
\fIchecking\fP as \fINOT_CHECKED\fP the function won\(cq\&t terminate the
script\&. Rather, it will return the called command\(cq\&s exit status, or
\fI0x7f00\fP if the command wasn\(cq\&t found\&.
.IP 
.IP o 
\fIstring trim(string s)\fP
.br 
Returns a copy of \fIs\fP without leading and trailing white spaces\&.
.IP 
.IP o 
\fIstring trimleft(string str)\fP
.br 
Returns a copy of \fIs\fP without leading white spaces\&.
.IP 
.IP o 
\fIstring trim(string s)\fP
.br 
Returns a copy of \fIs\fP without trailing white spaces\&.

.PP 
.SH "USER DEFINED FUNCTIONS"

.PP 
\fBvoid main\fP
.PP 
\fBIcmake\fP scripts must be provided with a user\-defined function \fImain\fP\&. The
function \fImain\fP has three optional parameters, which may be omitted from the
last one (\fIenvp\fP) to the first (\fIargc\fP), like in \fBC\fP\&. Its full prototype
is (note: \fBvoid\fP return type):
.nf 

    void main(int argc, list argv, list envp)
        
.fi 
In \fImain()\fP,
.IP o 
\fIargc\fP represents the number of elements in \fIargv\fP;
.IP 
.IP o 
\fIargv\fP contains the arguments, with element 0 being equal to the
name of the \&.bim file;
.IP 
.IP o 
\fIenvp\fP contains the `environment\(cq\& variables\&. The function \fIlistlen\fP
can be used to determine the number of its elements\&. Elements in \fIenvp\fP have
the form \fIvariable=value\fP\&. Alternatively, the function \fIgetenv\fP can be
used to retrieve a specific environment variable immediately\&.
Example:
.nf 

    void main(int argc, list argv)
    {
        list toCompile;
        int idx;

        if (argc == 1)
            usage(element(0, argv));

        if (toCompile = altered(\(dq\&*\&.cc\(dq\&))
        {
            for (idx = length(toCompile); idx\-\-; )
                compile(element(idx, toCompile));

            if (getenv(\(dq\&dryrun\(dq\&)[0] == \(dq\&0\(dq\&)
                linking(element(2, argv));
        }
    }    
        
.fi 

.PP 
Having initialized all global variables in order of their definitions \fImain\fP
is called by \fBicmake\fP\(cq\&s run\-time support system to perform additional
tasks\&. 
.PP 
\fBAdditionally defined user functions\fP
.PP 
Additional functions may be defined\&. Once defined, these functions can
be called\&. Forward referencing of either variables or functions is not
supported, but recursively calling functions is\&. As function declarations are
not supported indirect recursion is not supported either\&.
.PP 
User\-defined functions must have the following elements:
.IP o 
The function\(cq\&s return type, which must be one of \fIvoid, int,
string\fP or \fIlist\fP\&.  There is no default type\&. 
.IP 
.IP o 
The function\(cq\&s name, e\&.g\&., \fIcompile\fP\&.
.IP 
.IP o 
A parameter list, defining zero or more comma\-separated
parameters\&. The parameters themselves consist of a type name (\fIint,
string\fP, or \fIlist\fP) followed by the parameter\(cq\&s identifier\&. E\&.g\&.,
\fI(string outfile, string source)\fP\&.
.IP 
.IP o 
A \fIbody\fP surrounded by a pair of curly braces (\fI{\fP and \fI}\fP)\&.

.PP 
Function bodies may contain (optionally initialized) variable
definitions\&. Variable definitions start with a type name, followed by one or
more comma separated (optionally initialized) variable identifiers\&.  If a
variable is not explicitly initialized it is initialized by default\&. By
default an \fIint\fP variable is initialized to 0, a \fIstring\fP is initialized
to an empty string (\fI\(dq\&\(dq\&\fP) and a \fIlist\fP is initialized to a list of zero
elements\&.
.PP 
In addition to variable definitions, bodies may contain zero or more
statements (cf\&. section \fBFLOW CONTROL\fP)\&. Note that variables may be defined
(and optionally initialized) anywhere inside functions, and also in \fIif,
for\fP and \fIwhile\fP statements\&.
.PP 
The behavior of \fBicmake\fP\-scripts using non\-void functions that do not return
values is not defined\&. 
.PP 
.SH "FILES"

.PP 
The mentioned paths are sugestive only and may vary over different
\fBicmake\fP\-installations:
.IP o 
\fB/usr/bin/icmake\fP: the main \fBicmake\fP program;
.IP o 
\fB/usr/bin/icmun\fP: the \fBicmake\fP unassembler;
.IP o 
\fB/usr/lib/icmake/icm\-dep\fP: the support program handling class\- and
precompiled header dependencies;
.IP o 
\fB/usr/lib/icmake/icm\-pp\fP: the preprocessor called by \fBicmake\fP;
.IP o 
\fB/usr/lib/icmake/icm\-comp\fP: the compiler called by \fBicmake\fP;
.IP o 
\fB/usr/lib/icmake/icm\-exec\fP: the byte\-code interpreter called by
\fBicmake\fP; 

.PP 
.SH "EXAMPLES"

.PP 
The distribution (usually in \fI/usr/share/doc/icmake\fP) contains a
directory \fIexamples\fP containing various examples of \fBicmake\fP script\&. Note in
particular the \fIexamples/icmbuild\fP subdirectory containing a general script
for \fBC++\fP and \fBC\fP program maintenance\&.
.PP 
.SH "SEE ALSO"
\fBicmbuild\fP(1), \fBicmconf\fP(7), 
\fBicmstart\fP(1), \fBicmstart\&.rc\fP(7), \fBmake\fP(1)
.PP 
.SH "BUGS"
Standard comment starting  on lines containing preprocessor directives
may not extend over multiple lines\&.
.PP 
.SH "COPYRIGHT"
This is free software, distributed under the terms of the 
GNU General Public License (GPL)\&.
.PP 
.SH "AUTHOR"
Frank B\&. Brokken (\fBf\&.b\&.brokken@rug\&.nl\fP)\&.
.PP 
